---
title: 框架
date: 2017-02-11 09:42:15
tags:
---

# volley
库大小100k左右。
```
compile 'com.android.volley:volley:1.0.0'
```
## 1.请求
cache dispatcher     ---->       network dispatcher
1）如果 http请求的头信息中 的cache-control  max-age字段 未过期则使用 cache   ttl(time to live)存活时间
BasicNetwork.java
```
    @Override
    public NetworkResponse performRequest(Request<?> request) throws VolleyError {
        long requestStart = SystemClock.elapsedRealtime();
        while (true) {
            HttpResponse httpResponse = null;
            byte[] responseContents = null;
            Map<String, String> responseHeaders = Collections.emptyMap();
            try {
                // Gather headers.
                Map<String, String> headers = new HashMap<String, String>();
                addCacheHeaders(headers, request.getCacheEntry());
                ...
```
addCacheHeaders() 请求head会加入 "If-None-Match"（服务器上次返回的Last-Modified响应头中的日期值）， "If-Modified-Since"（服务器上次返回的ETag响应头的值）  进行条件请求，以便返回304
```
    private void addCacheHeaders(Map<String, String> headers, Cache.Entry entry) {
        // If there's no cache entry, we're done.
        if (entry == null) {
            return;
        }

        if (entry.etag != null) {
            headers.put("If-None-Match", entry.etag);
        }

        if (entry.lastModified > 0) {
            Date refTime = new Date(entry.lastModified);
            headers.put("If-Modified-Since", DateUtils.formatDate(refTime));
        }
    }

```

2）如果 max-age 过期 则先显示缓存再发network dispatcher 发netwokr请求 返回304／200 把缓存写入硬盘  返回结果



## 2. 缓存
二级缓存
1）DiskCache        
2）LruImageCache
## 3.重试
DefaultRetryPolicy   DEFAULT_MAX_RETRIES
## 4.超时
DefaultRetryPolicy  DEFAULT_TIMEOUT_MS
1）请求超时
2）接收数据超时
## 5.日志
VolleyLog

------

# retrofit
retrofit-2.1.0.jar大小为86.2K
okhttp-3.5.0.jar包大小342K
```
compile 'com.squareup.retrofit2:retrofit:2.1.0'
compile 'com.squareup.retrofit2:converter-gson:2.1.0'
compile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'
```

## 创建
```
new Retrofit.Builder()  
                .addConverterFactory(GsonConverterFactory.create())  
                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())  
                .build();  
```
## 流程
![](http://7xoxmg.com1.z0.glb.clouddn.com/retrofit.jpg)

## API
| 序号      | 名称           |    类别    | 备注 |
| -------- | -------------  |   ----    | ---  |
| 1        | @GET            | 请求方法  |  http get |
| 2        | @POST           | 请求方法  |  http post|
| 3        | @PUT            | 请求方法  |  http put | 
| 4        | @DELETE         | 请求方法  |  http delete | 
| 5        | @PATCH          | 请求方法  |  http patch | 
| 6        | @HEAD           | 请求方法  |  http head | 
| 7        | @OPTIONS        | 请求方法  |  http options | 
| 8        | @HTTP           | 请求方法  |  可代替以上7个及扩展方法；有3个属性：method、path、hasBody |
| 9        | @FormUrlEncoded | 方法标记  |  请求体是 From 表单 | 
| 10       | @Multipart      | 方法标记  |  请求体是支持文件上传的 From 表单 | 
| 11       | @Streaming      | 方法标记  |  响应体的数据用流的形式返回 | 
| 12       | @Headers        | 方法标记  |  添加固定的请求头 | 
| 13       | @Header         | 参数标记  |  添加动态的请求头 | 
| 14       | @Body           | 参数标记  |  请求体 | 
| 15       | @Field          | 参数标记  |  单个表单字段 | 
| 16       | @FieldMap       | 参数标记  |  多个表单字段 | 
| 17       | @Part           | 参数标记  |  单文件上传参数 | 
| 18       | @PartMap        | 参数标记  |  多文件上传参数 | 
| 19       | @Path           | 参数标记  |  URL拼接 | 
| 20       | @Query          | 参数标记  |  单个get参数 | 
| 21       | @QueryMap       | 参数标记  |  多个get参数 | 
| 22       | @Url            | 参数标记  |  url | 

## timeout
OkHttpClient.java 
default:
```
      connectTimeout = 10_000;
      readTimeout = 10_000;
      writeTimeout = 10_000;

```

## retry
rxjava:
Observable.java
```
@GET("/data.json")
Observable<DataResponse> fetchSomeData();
```
```
restApi.fetchSomeData()
.retry(5)  // Retry the call 5 times if it errors
.subscribeOn(Schedulers.io())  // execute the call asynchronously
.observeOn(AndroidSchedulers.mainThread())  // handle the results in the ui thread
.subscribe(onComplete, onError); 
// onComplete and onError are of type Action1<DataResponse>, Action1<Throwable>
// Here you can define what to do with the results

```

## Log
```
compile 'com.squareup.okhttp3:logging-interceptor:3.2.0'
```

```
HttpLoggingInterceptor logging = new HttpLoggingInterceptor();  
// set your desired log level
logging.setLevel(HttpLoggingInterceptor.Level.BODY);
OkHttpClient.Builder httpClient = new OkHttpClient.Builder();   
// add your other interceptors …
// add logging as last interceptor
httpClient.addInterceptor(logging);  // <-- this is the important line!
Retrofit retrofit = new Retrofit.Builder()  
.baseUrl(API_BASE_URL)
.addConverterFactory(GsonConverterFactory.create())
.client(httpClient.build())
.build();
```

## cancel task
rxjava:
```
if (!subscription.isUnsubscribed()) {
    subscription.unsubscribe();
}
```
[原理](https://gank.io/post/56e80c2c677659311bed9841)

## cache（文件缓存）
默认无cache，需要自己添加
```
OkHttpClient okHttpClient = new OkHttpClient();
File cacheFile = new File(context.getCacheDir(), "[缓存目录]");
Cache cache = new Cache(cacheFile, 1024 * 1024 * 100); //100Mb
okHttpClient.setCache(cache);
```
如果超过的最大缓存。linkedHashmap 删除第一条数据（最旧的数据）
[参考](http://www.jianshu.com/p/9c3b4ea108a7)


## Interceptor
[官方文档](https://github.com/square/okhttp/wiki/Interceptors)
文档解释：观察，修改以及可能短路的请求输出和响应请求的回来。通常情况下拦截器用来添加，移除或者转换请求或者回应的头部信息。 拦截器接口中有intercept(Chain chain)方法，同时返回Response。这里有一个简单的拦截弹，它记录了即将到来的请求和输入的响应。

```
class LoggingInterceptor implements Interceptor {
  @Override public Response intercept(Chain chain) throws IOException {
    Request request = chain.request();
    long t1 = System.nanoTime();
    logger.info(String.format("Sending request %s on %s%n%s",
        request.url(), chain.connection(), request.headers()));
    Response response = chain.proceed(request);
    long t2 = System.nanoTime();
    logger.info(String.format("Received response for %s in %.1fms%n%s",
        response.request().url(), (t2 - t1) / 1e6d, response.headers()));
    return response;
  }
}
```
![](https://raw.githubusercontent.com/mxn21/mxn21.github.io/master/public/img/img99.png)

## 线程控制
Rxjava：
computation(): 默认，线程池大小等于cpu数
io(): CachedThreadScheduler 缓冲线程池，大小1~ Integer.MAX_VALUE
newThread(): 新线程
trampoline(): 为当前线程建立一个队列，将当前任务加入到队列中依次执行
immediate(): 这个调度器允许你立即在当前线程执行你指定的工作
 

## https
[okHttp完美支持Https传输](http://blog.csdn.net/sk719887916/article/details/51597816)
[ Retrofit中如何正确的使用https？](http://blog.csdn.net/dd864140130/article/details/52625666)

## Cookie
[Okhttp完美同步持久Cookie实现免登录](http://www.jianshu.com/p/1a5f14b63f47)

## 文件上传
[轻松实现多文件/图片上传/Json字符串/表单](http://www.jianshu.com/p/acfefb0a204f)

## 断点续传
[完成大文件断点下载](http://www.jianshu.com/p/582e0a4a4ee9)

# glide
glide-3.6.1.jar 464.1 KB
okhttp-integration-1.3.1.jar 5.32 KB
okhttp-3.5.0.jar包大小342K

```
compile 'com.github.bumptech.glide:glide:3.6.1'

```
## cache (3级缓存)
### memeryCache
memeryCache 默认2屏

GlideBuilder.setMemoryCache(new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());

```
    static final int MEMORY_CACHE_TARGET_SCREENS = 2;
    private float memoryCacheScreens = MEMORY_CACHE_TARGET_SCREENS;
```
### bitmap cache
bitmap pool 默认缓存4屏
GlideBuilder.setBitmapPool(new LruBitmapPool(size));
```
    static final int BITMAP_POOL_TARGET_SCREENS = 4;
    private float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
```
### disk cache
DiskCache.java
GlideBuilder.setDiskCache(new InternalCacheDiskCacheFactory(context));
```
      /** 250 MB of cache. */
      int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
```

## 线程
### sourceExecutor
GlideExecutor.java calculateBestThreadCount();
```
Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount))
```
### diskCacheExecutor
默认1个线程
```
  public static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;

```

## timeout
### 默认HttpURLConnection timeout 2500；
HttpUrlFetcher.java
```
        urlConnection.setConnectTimeout(2500);
        urlConnection.setReadTimeout(2500);
        urlConnection.setUseCaches(false);

```
### 自定义timeout
#### 加入okhttp集成包
```
dependencies {  
    // your other dependencies
    // ...

    // Glide
    compile 'com.github.bumptech.glide:glide:3.6.1'

    // Glide's OkHttp Integration 
    compile 'com.github.bumptech.glide:okhttp-integration:1.3.1@aar'
    compile 'com.squareup.okhttp:okhttp:2.5.0'
}
```
#### 自定义OkHttpGlideModule
```
public class CustomGlideModule extends OkHttpGlideModule {
    @Override
    public void applyOptions(Context context, GlideBuilder builder) {
        // stub
    }

    @Override
    public void registerComponents(Context context, Glide glide) {
        final OkHttpClient.Builder builder = new OkHttpClient.Builder();

        // set your timeout here
        builder.readTimeout(30, TimeUnit.SECONDS);
        builder.writeTimeout(30, TimeUnit.SECONDS);
        builder.connectTimeout(30, TimeUnit.SECONDS);

        glide.register(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory(builder.build()));
    }
}
```
