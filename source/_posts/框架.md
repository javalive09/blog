---
title: 框架
date: 2017-02-11 09:42:15
tags:
---

# volley
库大小100k左右。
```
compile 'com.android.volley:volley:1.0.0'
```
## 1.请求
cache dispatcher     ---->       network dispatcher
1）如果 http请求的头信息中 的cache-control  max-age字段 未过期则使用 cache   ttl(time to live)存活时间
BasicNetwork.java
```
    @Override
    public NetworkResponse performRequest(Request<?> request) throws VolleyError {
        long requestStart = SystemClock.elapsedRealtime();
        while (true) {
            HttpResponse httpResponse = null;
            byte[] responseContents = null;
            Map<String, String> responseHeaders = Collections.emptyMap();
            try {
                // Gather headers.
                Map<String, String> headers = new HashMap<String, String>();
                addCacheHeaders(headers, request.getCacheEntry());
                ...
```
addCacheHeaders() 请求head会加入 "If-None-Match"（服务器上次返回的Last-Modified响应头中的日期值）， "If-Modified-Since"（服务器上次返回的ETag响应头的值）  进行条件请求，以便返回304
```
    private void addCacheHeaders(Map<String, String> headers, Cache.Entry entry) {
        // If there's no cache entry, we're done.
        if (entry == null) {
            return;
        }

        if (entry.etag != null) {
            headers.put("If-None-Match", entry.etag);
        }

        if (entry.lastModified > 0) {
            Date refTime = new Date(entry.lastModified);
            headers.put("If-Modified-Since", DateUtils.formatDate(refTime));
        }
    }

```

2）如果 max-age 过期 则先显示缓存再发network dispatcher 发netwokr请求 返回304／200 把缓存写入硬盘  返回结果



## 2. 缓存
二级缓存
1）DiskCache        
2）LruImageCache
## 3.重试
DefaultRetryPolicy   DEFAULT_MAX_RETRIES
## 4.超时
DefaultRetryPolicy  DEFAULT_TIMEOUT_MS
1）请求超时
2）接收数据超时
## 5.日志
VolleyLog

------

# retrofit
retrofit-2.1.0.jar大小为86.2K
okhttp-3.5.0.jar包大小342K
```
compile 'com.squareup.retrofit2:retrofit:2.1.0'
compile 'com.squareup.retrofit2:converter-gson:2.1.0'
compile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'
```

## 创建
```
new Retrofit.Builder()  
                .addConverterFactory(GsonConverterFactory.create())  
                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())  
                .build();  
```
## 流程
![](/images/retrofit.png)
![](/images/retrofit2.png)
## API
| 序号      | 名称           |    类别    | 备注 |
| -------- | -------------  |   ----    | ---  |
| 1        | @GET            | 请求方法  |  http get |
| 2        | @POST           | 请求方法  |  http post|
| 3        | @PUT            | 请求方法  |  http put | 
| 4        | @DELETE         | 请求方法  |  http delete | 
| 5        | @PATCH          | 请求方法  |  http patch | 
| 6        | @HEAD           | 请求方法  |  http head | 
| 7        | @OPTIONS        | 请求方法  |  http options | 
| 8        | @HTTP           | 请求方法  |  可代替以上7个及扩展方法；有3个属性：method、path、hasBody |
| 9        | @FormUrlEncoded | 方法标记  |  请求体是 From 表单 | 
| 10       | @Multipart      | 方法标记  |  请求体是支持文件上传的 From 表单 | 
| 11       | @Streaming      | 方法标记  |  响应体的数据用流的形式返回 | 
| 12       | @Headers        | 方法标记  |  添加固定的请求头 | 
| 13       | @Header         | 参数标记  |  添加动态的请求头 | 
| 14       | @Body           | 参数标记  |  请求体 | 
| 15       | @Field          | 参数标记  |  单个表单字段 | 
| 16       | @FieldMap       | 参数标记  |  多个表单字段 | 
| 17       | @Part           | 参数标记  |  单文件上传参数 | 
| 18       | @PartMap        | 参数标记  |  多文件上传参数 | 
| 19       | @Path           | 参数标记  |  URL拼接 | 
| 20       | @Query          | 参数标记  |  单个get参数 | 
| 21       | @QueryMap       | 参数标记  |  多个get参数 | 
| 22       | @Url            | 参数标记  |  url | 

## timeout
OkHttpClient.java 
default:
```
      connectTimeout = 10_000;
      readTimeout = 10_000;
      writeTimeout = 10_000;

```

## retry
rxjava:
Observable.java
```
@GET("/data.json")
Observable<DataResponse> fetchSomeData();
```
```
restApi.fetchSomeData()
.retry(5)  // Retry the call 5 times if it errors
.subscribeOn(Schedulers.io())  // execute the call asynchronously
.observeOn(AndroidSchedulers.mainThread())  // handle the results in the ui thread
.subscribe(onComplete, onError); 
// onComplete and onError are of type Action1<DataResponse>, Action1<Throwable>
// Here you can define what to do with the results

```

## Log
```
compile 'com.squareup.okhttp3:logging-interceptor:3.2.0'
```

```
HttpLoggingInterceptor logging = new HttpLoggingInterceptor();  
// set your desired log level
logging.setLevel(HttpLoggingInterceptor.Level.BODY);
OkHttpClient.Builder httpClient = new OkHttpClient.Builder();   
// add your other interceptors …
// add logging as last interceptor
httpClient.addInterceptor(logging);  // <-- this is the important line!
Retrofit retrofit = new Retrofit.Builder()  
.baseUrl(API_BASE_URL)
.addConverterFactory(GsonConverterFactory.create())
.client(httpClient.build())
.build();
```

## cancel task
rxjava:
```
if (!subscription.isUnsubscribed()) {
    subscription.unsubscribe();
}
```
[原理](https://gank.io/post/56e80c2c677659311bed9841)

## cache（文件缓存）
默认无cache，需要自己添加
```
OkHttpClient okHttpClient = new OkHttpClient();
File cacheFile = new File(context.getCacheDir(), "[缓存目录]");
Cache cache = new Cache(cacheFile, 1024 * 1024 * 100); //100Mb
okHttpClient.setCache(cache);
```
如果超过的最大缓存。linkedHashmap 删除第一条数据（最旧的数据）
[参考](http://www.jianshu.com/p/9c3b4ea108a7)


## Interceptor
[官方文档](https://github.com/square/okhttp/wiki/Interceptors)
文档解释：观察，修改以及可能短路的请求输出和响应请求的回来。通常情况下拦截器用来添加，移除或者转换请求或者回应的头部信息。 拦截器接口中有intercept(Chain chain)方法，同时返回Response。这里有一个简单的拦截弹，它记录了即将到来的请求和输入的响应。

```
class LoggingInterceptor implements Interceptor {
  @Override public Response intercept(Chain chain) throws IOException {
    Request request = chain.request();
    long t1 = System.nanoTime();
    logger.info(String.format("Sending request %s on %s%n%s",
        request.url(), chain.connection(), request.headers()));
    Response response = chain.proceed(request);
    long t2 = System.nanoTime();
    logger.info(String.format("Received response for %s in %.1fms%n%s",
        response.request().url(), (t2 - t1) / 1e6d, response.headers()));
    return response;
  }
}
```
![](/images/okhttp.png)

## 线程控制
Rxjava：
computation(): 默认，线程池大小等于cpu数
io(): CachedThreadScheduler 缓冲线程池，大小1~ Integer.MAX_VALUE
newThread(): 新线程
trampoline(): 为当前线程建立一个队列，将当前任务加入到队列中依次执行
immediate(): 这个调度器允许你立即在当前线程执行你指定的工作
 

## https
[okHttp完美支持Https传输](http://blog.csdn.net/sk719887916/article/details/51597816)
[ Retrofit中如何正确的使用https？](http://blog.csdn.net/dd864140130/article/details/52625666)

## Cookie
[Okhttp完美同步持久Cookie实现免登录](http://www.jianshu.com/p/1a5f14b63f47)

## 文件上传
[轻松实现多文件/图片上传/Json字符串/表单](http://www.jianshu.com/p/acfefb0a204f)

## 断点续传
[完成大文件断点下载](http://www.jianshu.com/p/582e0a4a4ee9)

# glide
glide-3.6.1.jar 464.1 KB
okhttp-integration-1.3.1.jar 5.32 KB
okhttp-3.5.0.jar包大小342K

```
compile 'com.github.bumptech.glide:glide:3.6.1'

```
## cache (3级缓存)
### memeryCache
memeryCache 默认2屏

GlideBuilder.setMemoryCache(new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());

```
    static final int MEMORY_CACHE_TARGET_SCREENS = 2;
    private float memoryCacheScreens = MEMORY_CACHE_TARGET_SCREENS;
```
### bitmap cache
bitmap pool 默认缓存4屏
GlideBuilder.setBitmapPool(new LruBitmapPool(size));
```
    static final int BITMAP_POOL_TARGET_SCREENS = 4;
    private float bitmapPoolScreens = BITMAP_POOL_TARGET_SCREENS;
```
### disk cache
DiskCache.java
GlideBuilder.setDiskCache(new InternalCacheDiskCacheFactory(context));
```
      /** 250 MB of cache. */
      int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
```

## 线程
### sourceExecutor
GlideExecutor.java calculateBestThreadCount();
```
Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount))
```
### diskCacheExecutor
默认1个线程
```
  public static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;

```

## timeout
### 默认HttpURLConnection timeout 2500；
HttpUrlFetcher.java
```
        urlConnection.setConnectTimeout(2500);
        urlConnection.setReadTimeout(2500);
        urlConnection.setUseCaches(false);

```
### 自定义timeout
#### 加入okhttp集成包
```
dependencies {  
    // your other dependencies
    // ...

    // Glide
    compile 'com.github.bumptech.glide:glide:3.6.1'

    // Glide's OkHttp Integration 
    compile 'com.github.bumptech.glide:okhttp-integration:1.3.1@aar'
    compile 'com.squareup.okhttp:okhttp:2.5.0'
}
```
#### 自定义OkHttpGlideModule
##### 第一步：gradle 引入okhttp3-integration 资源

```
   compile 'com.github.bumptech.glide:okhttp3-integration:1.4.0@aar'
```

##### 第二步：自定义OkHttpGlideModule

```
public class CustomGlideModule extends OkHttpGlideModule {
    @Override
    public void applyOptions(Context context, GlideBuilder builder) {
        // stub
    }

    @Override
    public void registerComponents(Context context, Glide glide) {
        final OkHttpClient.Builder builder = new OkHttpClient.Builder();

        // set your timeout here
        builder.readTimeout(30, TimeUnit.SECONDS);
        builder.writeTimeout(30, TimeUnit.SECONDS);
        builder.connectTimeout(30, TimeUnit.SECONDS);

        glide.register(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory(builder.build()));
    }
}
```

##### 第三步： AndroidManifest添加metedata标记

```
        <meta-data
            android:name="peter.util.searcher.net.CustomGlideModule"
            android:value="GlideModule" />

```

##### 第四步： 添加keep到proguard文件中

```
-keep class com.bumptech.glide.integration.okhttp3.OkHttpGlideModule

```

# cron4j
[官网](http://www.sauronsoftware.it/projects/cron4j/manual.php)
[github](https://github.com/Takuto88/cron4j)

## demo

```
import it.sauronsoftware.cron4j.Scheduler;

public class Quickstart {

    private static Scheduler s;
    private static String scheduleTaskId;

    public static void main(String[] args) {
        // Creates a Scheduler instance.
        s = new Scheduler();
        // Schedule a once-a-minute task.
        scheduleTaskId = s.schedule("* * * * *", new Runnable() {
            public void run() {
                System.out.println("Another minute ticked away...");
            }
        });
        // Starts the scheduler.
        s.start();
        // Will run for ten minutes.
        try {
            Thread.sleep(1000L * 60L * 10L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // Stops the scheduler. this method will block, Before returning, it waits the
        // end of all the running tasks previously launched
        s.stop();
    }

    public void cancelTask() {
        s.deschedule(scheduleTaskId);
    }

}

```

## TimerThread如何保证在每分钟的毫秒起始点执行Launch
run 代码如下：
```
    public void run() {
        // What time is it?
        long millis = System.currentTimeMillis();
        // Calculating next minute.
        long nextMinute = ((millis / 60000) + 1) * 60000;
        // Work until the scheduler is started.
        for (;;) {
            // Coffee break 'till next minute comes!
            long sleepTime = (nextMinute - System.currentTimeMillis());
            if (sleepTime > 0) {
                try {
                    safeSleep(sleepTime);
                } catch (InterruptedException e) {
                    // Must exit!
                    break;
                }
            }
            // What time is it?
            millis = System.currentTimeMillis();
            // Launching the launching thread!
            scheduler.spawnLauncher(millis);
            // Calculating next minute.
            nextMinute = ((millis / 60000) + 1) * 60000;
        }
        // Discard scheduler reference.
        scheduler = null;
    }
```
核心代码：
```
long nextMinute = ((millis / 60000) + 1) * 60000; //下一个整点分钟对应的毫秒

long sleepTime = (nextMinute - System.currentTimeMillis()); //当前时间和整点毫秒的差值

safeSleep(sleepTime);//睡眠差值毫秒时间  此后即在整点毫秒执行launch

```
# Gson
[官网](https://sites.google.com/site/gson/Home)
Gson是目前功能最全的Json解析神器。
## 基本使用
Gson提供了fromJson() 和toJson() 两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化。
```
User user = gson.fromJson(jsonString, User.class);
String jsonObject = gson.toJson(user);
```

## 容错 @SerializedName
```
//单容错
@SerializedName("email_address")
public String emailAddress;

//多容错
@SerializedName(value = "emailAddress", alternate = {"email", "email_address"})
public String emailAddress;
```

## 泛型 TypeToken
使用泛型不再重复定义Pojo类
```
// data 为 object 的情况
{"code":"0","message":"success","data":{}}
// data 为 array 的情况
{"code":"0","message":"success","data":[]}
...
```

```
public class Result<T> {
    public int code;
    public String message;
    public T data;
}
```

```
Type userType = new TypeToken<Result<User>>(){}.getType();
Result<User> userResult = gson.fromJson(json,userType);
User user = userResult.data;

Type userListType = new TypeToken<Result<List<User>>>(){}.getType();
Result<List<User>> userListResult = gson.fromJson(json,userListType);
List<User> users = userListResult.data;
```

## 自定义json输出字符 GsonBuilder

### 导出null值、格式化输出、日期时间等
Gson在默认情况下是不动导出值null的键的。
```
public class User {
    //省略其它
    public String name;
    public int age;
    public String email;
}
```
email字段是没有在json中出现

```
Gson gson = new Gson();
User user = new User("peter",24);
System.out.println(gson.toJson(user)); //{"name":"peter","age":24}
```

配置之后就可以输出了
```
Gson gson = new GsonBuilder()
        .serializeNulls()
        .create();
User user = new User("peter", 24);
System.out.println(gson.toJson(user)); //{"name":"peter","age":24,"email":null}
```
### 字段过滤 @Expose

```
@Expose //
@Expose(deserialize = true,serialize = true) //序列化和反序列化都都生效
@Expose(deserialize = true,serialize = false) //反序列化时生效
@Expose(deserialize = false,serialize = true) //序列化时生效
@Expose(deserialize = false,serialize = false) // 和不写一样
```

```
public class Category {
    @Expose public int id;
    @Expose public String name;
    @Expose public List<Category> children;
    //不需要序列化,所以不加 @Expose 注解，
    //等价于 @Expose(deserialize = false,serialize = false)
    public Category parent; 
}
```

```
Gson gson = new GsonBuilder()
        .excludeFieldsWithoutExposeAnnotation()
        .create();
gson.toJson(category);
```

### 基于版本导出
@Since 和 @Until都接收一个Double值。
@Since：大于等于Since的值时该字段导出。
@Until：小于Until的值时该该字段导出。
```
class SinceUntilSample {
    @Since(4)
    public String since;
    @Until(5)
    public String until;
}

public void sineUtilTest(double version){
        SinceUntilSample sinceUntilSample = new SinceUntilSample();
        sinceUntilSample.since = "since";
        sinceUntilSample.until = "until";
        Gson gson = new GsonBuilder().setVersion(version).create();
        System.out.println(gson.toJson(sinceUntilSample));
}
//当version <4时，结果：{"until":"until"}
//当version >=4 && version <5时，结果：{"since":"since","until":"until"}
//当version >=5时，结果：{"since":"since"}
```
### android studio 自动生成代码插件 RoboPOJOGenerator
[官网](https://github.com/robohorse/RoboPOJOGenerator)

# Rxjava
包大小 2.1M
[RxJava 源码](https://github.com/ReactiveX/RxJava)
[reactivex 官网](http://reactivex.io/)
[reactivex 中文文档](https://mcxiaoke.gitbooks.io/rxdocs/content/Intro.html)

使用
```
    implementation 'io.reactivex.rxjava2:rxandroid:2.0.1'
    implementation 'io.reactivex.rxjava2:rxjava:2.1.7'
```

![](/images/rxjava.png)



