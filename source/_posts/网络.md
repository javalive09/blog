---
title: 网络
date: 2017-02-11 08:52:34
tags:
---

# URI（uniformresource identifier）和URL（universal resource Loactor）的区别
一个URI定义了一种资源，它是一个定位符。
一个URI由两部分组成： scheme （URI协议名）：scheme-specific-part（URI协议对应的内容）
一个URL由三部分组成：scheme（协议）：// 主机IP地址  / 资源具体地址
一个URI是一个URL或URN
URL、URN是URI的子集
当对某种资源是URL还是URI产生疑惑时，用URI来定义它

------

# HTTP协议
超文本传输协议，用于网络间传输数据。传输的内容不仅是文本文字，还有图片，程序包，文件等各种格式的数据。
HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。
## 请求
请求行（负责请求的方式），消息头（负责请求的协议），正文（负责请求的内容）
## 响应
状态行（负责响应的状态提示），消息头（负责相应的协议），正文（负责响应的内容） 
### 状态码
1XX   提示消息（成功接收，继续处理）
2XX  成功
3XX  重定向
4XX  客户端错误（url 资源错误）
5XX  服务器端错误（服务端没实现此功能）
# OSI网络模型
7层，应用程（经理）：负责写草稿 / 阅读信件  --------------- 内容提供或阅读内容
6层，表示层（助理）：负责将草稿写成正规格式的信 / 翻译信的内容   ---------------加解密
5层，会话层（秘书）：负责写好信封（收信人地址） / 打开信件   ---------------建立通讯
4层，传输层（司机）：将信带到邮局 /  从邮局拿回信   ---------------确保数据传输

3层，网络层（排序工人）： 将信件根据收件地址分类  /  整理分类出信件    ---------------将发送方的数据传到接收方，路由器
2层，数据链路层（包装工人）：将信件包装 / 打开包装     ---------------管理比特数据，交换机
1层，物理层（搬运工人）： 将信件装上车 / 将信件卸下车    ---------------物理设备，传输高低电压，如电缆

------

# tcp连接 为什么要进行3次握手，断开为什么要4次握手
## 建立连接
* A打电话给B，需要询问，你是B么？
* B回答说我是B。
* A堆B说，我找的就是你。
至此，A知道找对了B。B也知道A是要找他。
> 如果不是3次握手的话，如果是客户端A和服务器B连接的话，A请求连接，B分配资源并回复的话，有可能会是A是误请求，这样容易造成资源浪费。
早期网络连接不稳定，引起路由寻址的问题，经常会连接出错，所以加了一次需要客户端A确认的操作。

相当于打电话时网络运营商连接了错的号码。
双方确定连接。
之后开始正式的传输数据。
### 断开连接
* A告诉B，我要说的说完了，我要挂电话了。
* B告诉A， 好的。
* B告诉A，我要说的也说完了，我也要挂电话了。
* A告诉B，好的。
双方确定彼此都要挂断电话后，正式断开连接。
## 什么是MIME
用于标记传输的数据的文件类型。
最早应用于电子邮件系统，但后来也应用到浏览器，以及所有的cs 交互模型中。在HTTP协议中用Content-type描述。
MIME(Multipurpose Internet Mail Extensions)
多用途互联网邮件扩展类型，是一个互联网标准，标准定义在 [RFC](http://www.cnpaf.net/class/rfcall/) 文档中。
http post提交表单格式数据 content-type ：application/x-www-form-urlencoded
http post提交json格式数据 content-type ：application/json


------

# UDP协议
## 概念
UDP: User Datagram Protocol 用户数据报协议 是一种无连接的协议。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。[参考](http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/) [Netty UDP 官方 demo](https://github.com/netty/netty/tree/4.0/example/src/main/java/io/netty/example/qotm)
## 使用
在选择使用协议的时候，选择UDP必须要谨慎。在网络质量令人十分不满意的环境下，UDP协议数据包丢失会比较严重。但是由于UDP的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多。
UDP广播：广播使用广播地址255.255.255.255，将消息发送到在同一广播网络上的每个主机。值得强调的是：本地广播信息是不会被路由器转发。当然这是十分容易理解的，因为如果路由器转发了广播信息，那么势必会引起网络瘫痪。这也是为什么IP协议的设计者故意没有定义互联网范围的广播机制。其实广播顾名思义，就是想局域网内所有的人说话，但是广播还是要指明接收者的端口号的，因为不可能接受者的所有端口都来收听广播。
## UDP广播
广播使用广播地址255.255.255.255，将消息发送到在同一广播网络上的每个主机。值得强调的是：本地广播信息是不会被路由器转发。当然这是十分容易理解的，因为如果路由器转发了广播信息，那么势必会引起网络瘫痪。这也是为什么IP协议的设计者故意没有定义互联网范围的广播机制。其实广播顾名思义，就是想局域网内所有的人说话，但是广播还是要指明接收者的端口号的，因为不可能接受者的所有端口都来收听广播。
### 发送接收代码
```
    public static void sendBroadcast(byte[] data, int port) throws Exception{
        DatagramSocket socket = new DatagramSocket();
        socket.setBroadcast(true);
        DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName("255.255.255.255"), port);
        socket.send(packet);
    }

    public static void receiveBoradcast(int port) {
        new Thread(new Runnable() {

            DatagramSocket socket;

            @Override
            public void run() {
                while (true) {
                    try {
                        receive(port);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }

            public void receive(int port) throws Exception{
                if (socket == null || socket.isClosed()) {
                    socket = new DatagramSocket(port);
                    socket.setBroadcast(true);
                }

                byte[] buffer = new byte[1024 * 100];
                DatagramPacket packet = new DatagramPacket(buffer , buffer.length);
                socket.receive(packet);
                String data = new String(packet.getData(), 0, packet.getLength());
                Log.i("receiver", data);
                socket.close();
            }

        }).start();
    }
```
### Netty 实现代码
```
public class Broadcast {

    Channel udpChannel;

    public void send(String data) throws Exception{
        if(udpChannel != null) {
            udpChannel.writeAndFlush(data);
        }
    }

    public void init(int port) {
        NioEventLoopGroup group = new NioEventLoopGroup();
        Bootstrap bootstrap = new Bootstrap();
        bootstrap.group(group)
                .channel(NioDatagramChannel.class)
                .option(ChannelOption.SO_BROADCAST, true)
                .handler(new MessageToMessageEncoder<String>() {
                    @Override
                    protected void encode(ChannelHandlerContext ctx, String msg, List<Object> out) throws Exception {
                        InetSocketAddress remoteAddress = new InetSocketAddress("255.255.255.255", port);
                        out.add(new DatagramPacket(Unpooled.copiedBuffer(msg, CharsetUtil.UTF_8), remoteAddress));
                    }
                });
        udpChannel = bootstrap.bind(0).syncUninterruptibly().channel();
    }

}

public class BroadcastReceiver {

    public void start(int port){
        Bootstrap b = new Bootstrap();
        NioEventLoopGroup group = new NioEventLoopGroup();
        try {
            b.group(group)
                    .channel(NioDatagramChannel.class)
                    .option(ChannelOption.SO_BROADCAST, true)
                    .handler(new SimpleChannelInboundHandler<DatagramPacket>() {

                        @Override
                        protected void messageReceived(ChannelHandlerContext ctx, DatagramPacket packet) throws Exception {
                            String req = packet.content().toString(CharsetUtil.UTF_8);
                            System.out.println(req);
                        }
                    });
            b.bind(port).sync().channel().closeFuture().await();
        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            group.shutdownGracefully();
        }
    }

}
```
## UDP多播
多播数据报套接字类用于发送和接收 IP 多播包。MulticastSocket 是一种 (UDP) DatagramSocket，它具有加入 Internet 上其他多播主机的“组”的附加功能。
多播组通过 D 类 IP 地址和标准 UDP 端口号指定。D 类 IP 地址在 224.0.0.0 和 239.255.255.255 的范围内（包括两者）。地址 224.0.0.0 被保留，不应使用。
### 多播代码
```
public class MultiBroadcast {

    public void startReveive(String host, int port) {

        new Thread(new Runnable() {

            MulticastSocket ms;

            private void receive(String host, int port) throws Exception{
                byte[] buf = new byte[1024 * 100];
                if(ms == null || ms.isClosed()) {
                    ms = new MulticastSocket(port);
                    DatagramPacket dp = new DatagramPacket(buf, buf.length);
                    InetAddress group = InetAddress.getByName(host);
                    ms.joinGroup(group);
                    ms.receive(dp);
                }

                Log.i("receiver", new String(buf));
                ms.close();
            }

            @Override
            public void run() {
                while (true) {
                    try {
                        receive(host, port);
                        Thread.sleep(100);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }

    public void send(String host, int port, String message) throws Exception{
        InetAddress group = InetAddress.getByName(host);
        MulticastSocket s = new MulticastSocket();
        s.joinGroup(group);
        DatagramPacket dp = new DatagramPacket(message.getBytes(),message.length(), group,port);
        s.send(dp);
        s.close();
    }

}
```
## UDP单播
```
public class UnicastBroadcast {

    public void send(String host, int port, byte[] message) throws Exception{
        //sending data to host and its port
        InetAddress address = InetAddress.getByName(host);
        // Initialize a datagram packet with data and address
        DatagramPacket packet = new DatagramPacket(message, message.length, address, port);
        // Create a datagram socket, send the packet through it, close it.
        DatagramSocket dsocket = new DatagramSocket();
        dsocket.send(packet);
        dsocket.close();
    }

    public void startReceive() {
        new Thread(new Runnable() {

            DatagramSocket dsocket;

            @Override
            public void run() {

            }

            private void receive(int port) throws Exception{

                byte[] buffer = new byte[2048];
                if(dsocket == null || dsocket.isClosed()) {
                    //receiving data from its port
                    dsocket = new DatagramSocket(port);
                    // Create a buffer to read datagrams into. If a
                    // packet is larger than this buffer, the
                    // excess will simply be discarded!

                    // Create a packet to receive data into the buffer
                    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

                    // Wait to receive a datagram
                    dsocket.receive(packet);
                    // Convert the contents to a string, and display them
                    String msg = new String(buffer);
                    System.out.println(packet.getAddress().getHostName() + ": " + msg);
                }
                
                dsocket.close();

            }

        }).start();
    }

}
```
# url编码问题
url 标准为美国制定，只支持asc编码，所以 
1. get 请求等需要传递汉子等非asc编码支持的字符时，违背的这个标准，需要url encode
2. 参数包含& = 等这些标准连接的特殊符号时，也需要url encode

# http（android api）
HttpURLConnection [代码demo](http://stackoverflow.com/questions/2793150/using-java-net-urlconnection-to-fire-and-handle-http-requests/2793153#2793153)

## 发送：
### 1.设置协议： 
con.setRequestMethod("post"), timeout 等。
### 2.发送内容：
os = con.getOutPutStream()。
os.writeBytes(json data 数据).toString()
### 3.发送流结构：
请求行（自动）
消息头（协议）
内容（数据）
## 接收：
1.con.getInputStream();
read();
2.接收流结构
状态行（状态码）
消息头（协议）
内容（数据）
> 注：https 
在上面的设置协议中加入：
1. setHostnameVerifier( );
2.构造器中加入 setDefaultSSLSocketFactory

# http（apache api）
## post发送：
```
1.pos = new HttpPost（url）
2.pos.setHeader()   协议
3.pos.setEntity（） json数据
4.re = new HttpClient（）.execute（pos）
5.EntityUtils.toString(re.getEntity（）)
```
## get发送：
```
1.get = new HttpGet（url）
2.get.setHeader()
3.re = new HttpClient().execute(get)
4. status = re.getStatusline().getStatusCode()
re.getEntity().getContent().
```




